1910B "Security Guard" "*special problem, greedy" "Monocarp is a security guard in Berland State University. Every day, he tracks how many people and at what time enter and leave the university. He writes this information down as follows: 
At the beginning of the current day, there are no people at the university, except for Monocarp. During the day, Monocarp wrote out a sequence s. The characters in s are listed in the order Monocarp wrote them.
Suddenly, Monocarp\'s boss decided to check his work. Unfortunately, Monocarp is a bit careless. So, the sequence s that he wrote might be impossible. For example, the sequence ""+--"" can\'t happen, since it represents a scenario when one person enters the university and two leave.
Before his boss starts checking the sequence, Monocarp has the time to swap at most one pair of characters in it. Can he do it in such a way that the resulting sequence is plausible? Note that if the given sequence is already plausible, Monocarp doesn\'t have to swap anything.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases.
The only line of each test case contains a single string s (1\xe2\x89\xa4|s|\xe2\x89\xa43\xe2\x8b\x85105), consisting only of characters \'+\' and/or \'-\'. A plus sign \'+\' represents a person entering the university. A minus sign \'-\' represents a person leaving the university.
The sum of all |s| over all test cases doesn\'t exceed 3\xe2\x8b\x85105.
For each test case, print an answer.
If it\'s impossible to swap at most one pair of characters so that the resulting sequence is plausible, print -1.
Otherwise, print two integers. If you swap one pair of characters, print two distinct integers from 1 to n \xe2\x80\x94 the indices of characters to swap. If you don\'t swap, print one integer from 1 to n twice \xe2\x80\x94 swap a character with itself.
If there are multiple answers, print any of them." "1600  x681"
1910A Username "*special problem, implementation" "On the official website of Berland, each account has two parameters: username and ID.
Username is a string consisting of lowercase Latin letters and/or digits, which contains at least one letter. For example, user0, 1fox1, zzzz are correct usernames, but 1337 and User22 are not. 
The ID of the account for a given username is generated as follows: a positive integer without leading zeroes is appended to the end of the username. For example, the ID user0125 can be generated by the following usernames: user012, user01, user0; but neither by user nor us.
You are given a string s \xe2\x80\x94 a valid ID. Your task is to determine any valid username that can generate the given ID. If there are several correct usernames, you can print any of them.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4103) \xe2\x80\x94 the number of test cases.
The only line of each test case contains a string s (2\xe2\x89\xa4|s|\xe2\x89\xa450), consisting of lowercase Latin letters and/or digits.
Additional constraint on input: there is at least one valid username that can generate the given ID.
For each test case on a separate line, print a string \xe2\x80\x94 any valid username that can generate the given ID. If there are multiple correct usernames, you can print any of them." "1100  x1792"
1909I "Short Permutation Problem" "combinatorics, dp, fft, math" "You are given an integer n.
For each (m,k) such that 3\xe2\x89\xa4m\xe2\x89\xa4n+1 and 0\xe2\x89\xa4k\xe2\x89\xa4n\xe2\x88\x921, count the permutations of [1,2,...,n] such that pi+pi+1\xe2\x89\xa5m for exactly k indices i, modulo 998244353.
The input consists of a single line, which contains two integers n, x (2\xe2\x89\xa4n\xe2\x89\xa44000, 1\xe2\x89\xa4x<1000000007).
Let am,k be the answer for the pair (m,k), modulo 998244353.
Let S=n+1\xe2\x88\x91m=3n\xe2\x88\x921\xe2\x88\x91k=0am,kxmn+k0.
Output a single line with an integer: S modulo 1000000007.
Note that using two different modulos is intentional. We want you to calculate all the am,k modulo 998244353, then treat them like integers in the range [0,998244352], and hash them modulo 1000000007.
In the first test case, the answers for all (m,k) are shown in the following table:
Therefore, the value to print is 29\xe2\x8b\x850+210\xe2\x8b\x850+211\xe2\x8b\x856+212\xe2\x8b\x850+213\xe2\x8b\x854+214\xe2\x8b\x852\xe2\x89\xa1778240(mod01000000007).
In the second test case, the answers for all (m,k) are shown in the following table:
In the third test case, the answers for all (m,k) are shown in the following table:" "1900  x119"
1909H "Parallel Swaps Sort" "constructive algorithms, data structures" "You are given a permutation p1,p2,\xe2\x80\xa6,pn of [1,2,\xe2\x80\xa6,n]. You can perform the following operation some (possibly 0) times:
Sort the permutation in at most 106 operations. You do not need to minimize the number of operations.
The first line contains a single integer n (2\xe2\x89\xa4n\xe2\x89\xa43\xe2\x8b\x85105) \xe2\x80\x94 the length of the permutation.
The second line contains n integers p1,p2,\xe2\x80\xa6,pn (1\xe2\x89\xa4pi\xe2\x89\xa4n, the pi are distinct) \xe2\x80\x94 the permutation before performing the operations.
Output your operations in the following format.
The first line should contain an integer k (0\xe2\x89\xa4k\xe2\x89\xa4106) \xe2\x80\x94 the number of operations.
The next k lines represent the k operations in order. Each of these k lines should contain two integers l and r (1\xe2\x89\xa4l<r\xe2\x89\xa4n, r\xe2\x88\x92l+1 must be even) \xe2\x80\x94 the corresponding operation consists in choosing the subarray [l,r] and swapping its elements according to the problem statement.
After all the operations, ai=i must be true for each i (1\xe2\x89\xa4i\xe2\x89\xa4n).
In the first test: 
In the second test, the permutation is already sorted, so you do not need to perform any operation." "3500  x80"
1909G "Pumping Lemma" "hashing, strings" "You are given two strings ss, tt of length nn, mm, respectively. Both strings consist of lowercase letters of the English alphabet.
Count the triples (x,y,z)(x,y,z) of strings such that the following conditions are true:
The first line contains two integers n and m (1\xe2\x89\xa4n<m\xe2\x89\xa4107) \xe2\x80\x94 the length of the strings s and t, respectively.
The second line contains the string s of length n, consisting of lowercase letters of the English alphabet.
The third line contains the string t of length m, consisting of lowercase letters of the English alphabet.
Output a single integer: the number of valid triples (x,y,z).
In the first test case, the only valid triple is (x,y,z)=(""a"",""bc"",""d""). In fact, 
In the second test case, there are 5 valid triples: 
In the third test case, there are 8 valid triples: " "3000  x416"
1909F2 "Small Permutation Problem (Hard Version)" "combinatorics, dp, math" "In the easy version, the aiai are in the range [0,n]; in the hard version, the ai are in the range [\xe2\x88\x921,n] and the definition of good permutation is slightly different. You can make hacks only if all versions of the problem are solved.
You are given an integer n and an array a1,a2,\xe2\x80\xa6,an of integers in the range [\xe2\x88\x921,n].
A permutation p1,p2,\xe2\x80\xa6,pn of [1,2,\xe2\x80\xa6,n] is good if, for each i, the following condition is true: 
Count the good permutations of [1,2,\xe2\x80\xa6,n], modulo 998244353.
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4104). The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the length of the array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (\xe2\x88\x921\xe2\x89\xa4ai\xe2\x89\xa4n), which describe the conditions for a good permutation.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output a single line containing the number of good permutations, modulo 998244353.
In the first test case, all the permutations of length 5 are good, so there are 120 good permutations.
In the second test case, the only good permutation is [1,2,3,4,5].
In the third test case, there are 4 good permutations: [2,1,5,6,3,4], [2,1,5,6,4,3], [2,1,6,5,3,4], [2,1,6,5,4,3]. For example, [2,1,5,6,3,4] is good because: " "2500  x951"
1909F1 "Small Permutation Problem (Easy Version)" "brute force, combinatorics, dp, math" "In the easy version, the aiai are in the range [0,n][0,n]; in the hard version, the aiai are in the range [\xe2\x88\x921,n][\xe2\x88\x921,n] and the definition of good permutation is slightly different. You can make hacks only if all versions of the problem are solved.
You are given an integer nn and an array a1,a2\xe2\x80\xa6,an of integers in the range [0,n].
A permutation p1,p2,\xe2\x80\xa6,pn of [1,2,\xe2\x80\xa6,n] is good if, for each i, the following condition is true: 
Count the good permutations of [1,2,\xe2\x80\xa6,n], modulo 998244353.
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4104). The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the length of the array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (0\xe2\x89\xa4ai\xe2\x89\xa4n), which describe the conditions for a good permutation.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output a single line containing the number of good permutations, modulo 998244353.
In the first test case, the only good permutation is [1,2,3,4,5].
In the second test case, there are 4 good permutations: [2,1,5,6,3,4], [2,1,5,6,4,3], [2,1,6,5,3,4], [2,1,6,5,4,3]. For example, [2,1,5,6,3,4] is good because: 
In the third test case, there are no good permutations, because there are no permutations with a6=5 values \xe2\x89\xa46 in [p1,p2,p3,p4,p5,p6]." "2200  x1848"
1909E "Multiple Lamps" "bitmasks, brute force, constructive algorithms, math, number theory" "You have nn lamps, numbered from 11 to nn. Initially, all the lamps are turned off.
You also have nn buttons. The ii-th button toggles all the lamps whose index is a multiple of ii. When a lamp is toggled, if it was off it turns on, and if it was on it turns off.
You have to press some buttons according to the following rules.
You don\'t want to waste too much electricity. Find a way to press buttons such that at the end at most \xe2\x8c\x8an/5\xe2\x8c\x8b lamps are on, or print \xe2\x88\x921 if it is impossible.
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4104). The description of the test cases follows.
The first line of each test case contains two integers n and m (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 0\xe2\x89\xa4m\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of lamps and the number of pairs, respectively.
Each of the next m lines contains two integers ui, vi (1\xe2\x89\xa4ui,vi\xe2\x89\xa4n, ui\xe2\x89\xa0vi). If you press the button ui, you also have to press the button vi. It is guaranteed that the pairs (ui,vi) are distinct.
It is guaranteed that the sum of n and the sum of m over all test cases do not exceed 2\xe2\x8b\x85105.
For each test case: 
In the first test case, you need to turn at most \xe2\x8c\x8a4/5\xe2\x8c\x8b lamps on, which means that no lamp can be turned on. You can show that no choice of at least one button turns 0 lamps on.
In the second test case, you can press buttons 3, 5, 1, 2.
This is valid because 
In the third test case, pressing the buttons 8, 9, 10 turns only the lamps 8, 9, 10 on." "2400  x1410"
1909D "Split Plus K" "greedy, math, number theory" "There are n positive integers a1,a2,\xe2\x80\xa6,an on a blackboard. You are also given a positive integer k. You can perform the following operation some (possibly 0) times:
Is it possible to make all the numbers on the blackboard equal? If yes, what is the minimum number of operations you need?
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4104). The description of the test cases follows.
The first line of each test case contains two integers n, k (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 1\xe2\x89\xa4k\xe2\x89\xa41012) \xe2\x80\x94 the number of integers initially on the blackboard and the constant k.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa41012) \xe2\x80\x94 the initial state of the blackboard.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output a single line containing an integer: the minimum number of operations you need to make all the numbers on the blackboard equal, or \xe2\x88\x921 if it is impossible.
In the first test case, k=1. You can make all the numbers on the blackboard equal to 2 with the following operations: 
This makes all the numbers equal in 3 operations. It can be shown that you cannot make all the numbers equal in less than 3 operations.
In the second test case, k=3. You can make all the numbers on the blackboard equal to 7 with the following operation: 
In the third test case, k=10. You can make all the numbers on the blackboard equal to 40 with the following operations: 
In the fourth and in the fifth test case, you can show that it is impossible to make all the numbers on the blackboard equal." "1900  x4484"
1909C "Heavy Intervals" "constructive algorithms, data structures, dsu, greedy, math, sortings" "You have nn intervals [l1,r1],[l2,r2],\xe2\x80\xa6,[ln,rn], such that li<ri for each i, and all the endpoints of the intervals are distinct.
The i-th interval has weight ci per unit length. Therefore, the weight of the i-th interval is ci\xe2\x8b\x85(ri\xe2\x88\x92li).
You don\'t like large weights, so you want to make the sum of weights of the intervals as small as possible. It turns out you can perform all the following three operations:
However, after performing all of the operations, the intervals must still be valid (i.e., for each i, li<ri must hold).
What\'s the minimum possible sum of weights of the intervals after performing the operations?
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4104). The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 the number of intervals.
The second line of each test case contains n integers l1,l2,\xe2\x80\xa6,ln (1\xe2\x89\xa4li\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the left endpoints of the initial intervals.
The third line of each test case contains n integers r1,r2,\xe2\x80\xa6,rn (li<ri\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the right endpoints of the initial intervals.
It is guaranteed that {l1,l2,\xe2\x80\xa6,ln,r1,r2,\xe2\x80\xa6,rn} are all distinct.
The fourth line of each test case contains n integers c1,c2,\xe2\x80\xa6,cn (1\xe2\x89\xa4ci\xe2\x89\xa4107) \xe2\x80\x94 the initial weights of the intervals per unit length.
It is guaranteed that the sum of n over all test cases does not exceed 105.
For each test case, output a single integer: the minimum possible sum of weights of the intervals after your operations.
In the first test case, you can make 
In that case, there are two intervals: 
The sum of the weights is 2400. It can be shown that there is no configuration of final intervals whose sum of weights is less than 2400.
In the second test case, you can make 
In that case, there are four intervals: 
The sum of the weights is 42. It can be shown that there is no configuration of final intervals whose sum of weights is less than 42." "1400  x11316"
1909B "Make Almost Equal With Mod" "bitmasks, constructive algorithms, math, number theory" "You are given an array a1,a2,\xe2\x80\xa6,an of distinct positive integers. You have to do the following operation exactly once:
Find a value of k such that 1\xe2\x89\xa4k\xe2\x89\xa41018 and the array a1,a2,\xe2\x80\xa6,an contains exactly 2 distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such k always exists. If there are multiple solutions, you can print any of them.
\xe2\x80\xa0 a mod b denotes the remainder after dividing a by b. For example: 
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa4500). The description of the test cases follows.
The first line of each test case contains a single integer n (2\xe2\x89\xa4n\xe2\x89\xa4100) \xe2\x80\x94 the length of the array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa41017) \xe2\x80\x94 the initial state of the array. It is guaranteed that all the ai are distinct.
Note that there are no constraints on the sum of n over all test cases.
For each test case, output a single integer: a value of k (1\xe2\x89\xa4k\xe2\x89\xa41018) such that the array a1,a2,\xe2\x80\xa6,an contains exactly 2 distinct values at the end of the operation.
In the first test case, you can choose k=7. The array becomes [8 mod 7,15 mod 7,22 mod 7,30 mod 7]=[1,1,1,2], which contains exactly 2 distinct values ({1,2}).
In the second test case, you can choose k=30. The array becomes [0,0,8,0,8], which contains exactly 2 distinct values ({0,8}). Note that choosing k=10 would also be a valid solution.
In the last test case, you can choose k=1018. The array becomes [2,1], which contains exactly 2 distinct values ({1,2}). Note that choosing k=1018+1 would not be valid, because 1\xe2\x89\xa4k\xe2\x89\xa41018 must be true." "1200  x17417"
1909A "Distinct Buttons" "implementation, math" "You are located at the point (0,0)(0,0) of an infinite Cartesian plane. You have a controller with 44 buttons which can perform one of the following operations:
Unfortunately, the controller is broken. If you press all the 4 buttons (in any order), the controller stops working. It means that, during the whole trip, you can only press at most 3 distinct buttons (any number of times, in any order).
There are n special points in the plane, with integer coordinates (xi,yi).
Can you visit all the special points (in any order) without breaking the controller?
Each test contains multiple test cases. The first line contains the number of test cases t (1\xe2\x89\xa4t\xe2\x89\xa41000). The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa4100) \xe2\x80\x94 the number of special points.
Each of the next n lines contains two integers xi, yi (\xe2\x88\x92100\xe2\x89\xa4xi,yi\xe2\x89\xa4100), which represent the special point (xi,yi).
Note that there are no constraints on the sum of n over all test cases.
For each test case, output ""YES"" (without quotes), if you can reach all the special points without breaking the controller, and ""NO"" (without quotes) otherwise.
You may output each letter in any case (for example, ""YES"", ""Yes"", ""yes"", ""yEs"" will all be recognized as positive answer).
In the first test case, you can move as follows: 
Therefore, you can visit all the special points using only the buttons R, D, so the controller does not break.
Note that the special points may coincide.
In the second test case, you can show that you can visit all the special points using only the buttons U, D, L.
In the third test case, you can show that you must press all the buttons (U, R, D, L) to visit all the points, so the controller would break." "800  x17946"
1907G Lights "brute force, constructive algorithms, dfs and similar, graphs, greedy, implementation" "In the end of the day, Anna needs to turn off the lights in the office. There are n lights and n light switches, but their operation scheme is really strange. The switch i changes the state of light i, but it also changes the state of some other light ai (change the state means that if the light was on, it goes off and vice versa).
Help Anna to turn all the lights off using minimal number of switches, or say it is impossible.
The first line of input contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. Descriptions of test cases follow.
The first line of each test case contains the integer n (2\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 the number of lights. 
The second line of each test case contains the string of n characters, the initial state of the lights. Character ""0"" means that the corresponding light is off, and ""1"" means that it is on. 
The third line of each test case contains n integers ai (1\xe2\x89\xa4ai\xe2\x89\xa4n, ai\xe2\x89\xa0i) \xe2\x80\x94 the switch i changes the states of light i and light ai.
It is guaranteed that sum of n over all test cases does not exceed 2\xe2\x8b\x85105
For each test case output the integer k, the minimal number of switches to use, then in the separate line output the list of k switches.
If it is impossible to turn off all the lights, output single integer \xe2\x88\x921." "2200  x1973"
1907F "Shift and Reverse" "greedy, sortings" "Given an array of integers a1,a2,\xe2\x80\xa6,ana1,a2,\xe2\x80\xa6,an. You can make two types of operations with this array: 
Your task is to sort the array in non-decreasing order using the minimal number of operations, or say that it is impossible.
The first line of input contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. Descriptions of test cases follow.
The first line of each test case contains an integer n (1\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 size of the array. 
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4109) \xe2\x80\x94 elements of the array.
It is guaranteed that sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case output the number k, the minimal number of operations you need to sort the array. If it is impossible to sort the array using these operations, output \xe2\x88\x921.
In the first test case of the example, to sort the array [3,2,1,5,4] you need to perform 3 operations:
In the third test case of the example, it can be shown that it is impossible to sort the array using the given operations.
In the seventh test case of the example, to sort the array [4,1,3,4,4] you need to perform 3 operations:" "1800  x4945"
1907E "Good Triples" "brute force, combinatorics, number theory" "Given a non-negative integer number n (n\xe2\x89\xa50). Let\'s say a triple of non-negative integers (a,b,c) is good if a+b+c=n, and digsum(a)+digsum(b)+digsum(c)=digsum(n), where digsum(x) is the sum of digits of number x.
For example, if n=26, then the pair (4,12,10) is good, because 4+12+10=26, and (4)+(1+2)+(1+0)=(2+6).
Your task is to find the number of good triples for the given number n. The order of the numbers in a triple matters. For example, the triples (4,12,10) and (10,12,4) are two different triples.
The first line of input contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. Descriptions of test cases follow.
The first and only line of the test case contains one integer n (0\xe2\x89\xa4n\xe2\x89\xa4107).
For each test case output one integer, the number of good triples for the given integer n. Order of integers in a triple matters.
In the first example, the good triples are (0,0,11), (0,1,10), (0,10,1), (0,11,0), (1,0,10), (1,10,0), (10,0,1), (10,1,0), (11,0,0).
In the second example, there is only one good triple (0,0,0)." "1600  x10470"
1907D "Jumping Through Segments" "binary search, constructive algorithms" "Polycarp is designing a level for a game. The level consists of nn segments on the number line, where the i-th segment starts at the point with coordinate li and ends at the point with coordinate ri.
The player starts the level at the point with coordinate 0. In one move, they can move to any point that is within a distance of no more than k. After their i-th move, the player must land within the i-th segment, that is, at a coordinate x such that li\xe2\x89\xa4x\xe2\x89\xa4ri. This means:
The level is considered completed if the player reaches the n-th segment, following the rules described above. After some thought, Polycarp realized that it is impossible to complete the level with some values of k.
Polycarp does not want the level to be too easy, so he asks you to determine the minimum integer k with which it is possible to complete the level.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104)\xe2\x80\x94the number of test cases. Descriptions of the test cases follow.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105)\xe2\x80\x94the number of segments in the level.
The following n lines.
The i-th line contain two integers li and ri (0\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa4109)\xe2\x80\x94the boundaries of the i-th segment. Segments may intersect.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output a single integer\xe2\x80\x94the minimum value of k with which it is possible to complete the level.
In the third example, the player can make the following moves:
Note that for the last move, the player could have chosen not to move and still complete the level." "1400  x14537"
1907C "Removal of Unattractive Pairs" "constructive algorithms, greedy, math, strings" "Vlad found a string s consisting of n lowercase Latin letters, and he wants to make it as short as possible.
To do this, he can remove any pair of adjacent characters from s any number of times, provided they are different. For example, if s=racoon, then by removing one pair of characters he can obtain the strings coon, roon, raon, and raco, but he cannot obtain racn (because the removed letters were the same) or rcon (because the removed letters were not adjacent).
What is the minimum length Vlad can achieve by applying any number of deletions?
The first line of the input contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. Descriptions of the test cases follow.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the length of the string s.
The second line of each test case contains the string s consisting of n lowercase Latin letters.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output a single number\xe2\x80\x94the minimum length of the string s, after removing pairs of adjacent characters with different values.
In the first test case of the example, you need to act as follows: ""aabc"" \xe2\x86\x92 ""ac"" \xe2\x86\x92 """". Note that with a different order of deletions, the string will not become empty." "1200  x20404"
1907B YetnotherrokenKeoard "data structures, implementation, strings" "Polycarp has a problem \xe2\x80\x94 his laptop keyboard is broken.
Now, when he presses the \'b\' key, it acts like an unusual backspace: it deletes the last (rightmost) lowercase letter in the typed string. If there are no lowercase letters in the typed string, then the press is completely ignored.
Similarly, when he presses the \'B\' key, it deletes the last (rightmost) uppercase letter in the typed string. If there are no uppercase letters in the typed string, then the press is completely ignored.
In both cases, the letters \'b\' and \'B\' are not added to the typed string when these keys are pressed.
Consider an example where the sequence of key presses was ""ARaBbbitBaby"". In this case, the typed string will change as follows: """" A\xe2\x86\x92 ""A"" R\xe2\x86\x92 ""AR"" a\xe2\x86\x92 ""ARa"" B\xe2\x86\x92 ""Aa"" b\xe2\x86\x92 ""A"" b\xe2\x86\x92 ""A"" i\xe2\x86\x92 ""Ai"" t\xe2\x86\x92 ""Ait"" B\xe2\x86\x92 ""it"" a\xe2\x86\x92 ""ita"" b\xe2\x86\x92 ""it"" y\xe2\x86\x92 ""ity"".
Given a sequence of pressed keys, output the typed string after processing all key presses.
The first line of the input data contains an integer t (1\xe2\x89\xa4t\xe2\x89\xa41000), the number of test cases in the test.
The following contains t non-empty lines, which consist of lowercase and uppercase letters of the Latin alphabet.
It is guaranteed that each line contains at least one letter and the sum of the lengths of the lines does not exceed 106.
For each test case, output the result of processing the key presses on a separate line. If the typed string is empty, then output an empty line." "1000  x25971"
1907A Rook implementation "As you probably know, chess is a game that is played on a board with 64 squares arranged in an 8\xc3\x978 grid. Columns of this board are labeled with letters from a to h, and rows are labeled with digits from 1 to 8. Each square is described by the row and column it belongs to.
The rook is a piece in the game of chess. During its turn, it may move any non-zero number of squares horizontally or vertically. Your task is to find all possible moves for a rook on an empty chessboard.
The first line of input contains single integer t (1\xe2\x89\xa4t\xe2\x89\xa464) \xe2\x80\x94 the number of test cases. The descriptions of test cases follow.
Each test case contains one string of two characters, description of the square where rook is positioned. The first character is a letter from a to h, the label of column, and the second character is a digit from 1 to 8, the label of row. 
The same position may occur in more than one test case.
For each test case, output descriptions of all squares where the rook can move, in the same format as in the input. 
You can output squares in any order per test case." "800  x37053"
1894A "Secret Sport" "implementation, strings" "Let\'s consider a game in which two players, A and B, participate. This game is characterized by two positive integers, XX and Y.
The game consists of sets, and each set consists of plays. In each play, exactly one of the players, either A or B, wins. A set ends exactly when one of the players reaches X wins in the plays of that set. This player is declared the winner of the set. The players play sets until one of them reaches Y wins in the sets. After that, the game ends, and this player is declared the winner of the entire game.
You have just watched a game but didn\'t notice who was declared the winner. You remember that during the game, n plays were played, and you know which player won each play. However, you do not know the values of X and Y. Based on the available information, determine who won the entire game \xe2\x80\x94 A or B. If there is not enough information to determine the winner, you should also report it.
Each test contains multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) - the number of test cases. The description of the test cases follows.
The first line of each test case contains an integer n (1\xe2\x89\xa4n\xe2\x89\xa420) - the number of plays played during the game.
The second line of each test case contains a string s of length n, consisting of characters A and B. If si=A, it means that player A won the i-th play. If si=B, it means that player B won the i-th play.
It is guaranteed that the given sequence of plays corresponds to at least one valid game scenario, for some values of X and Y.
For each test case, output:
In the first test case, the game could have been played with parameters X=3, Y=1. The game consisted of 1 set, in which player A won, as they won the first 3 plays. In this scenario, player A is the winner. The game could also have been played with parameters X=1, Y=3. It can be shown that there are no such X and Y values for which player B would be the winner.
In the second test case, player B won all the plays. It can be easily shown that in this case, player B is guaranteed to be the winner of the game.
In the fourth test case, the game could have been played with parameters X=3, Y=3:
In total, player B was the first player to win 3 sets. They are declared the winner of the game." "800  x19032"
1893E "Cacti Symphony" "combinatorics, dfs and similar, dp, graphs" "You are given an undirected connected graph in which any two distinct simple cycles do not have common vertices. Since the graph can be very large, it is given to you in a compressed form: for each edge, you are also given a number d, which indicates that there are d additional vertices on this edge.
You need to assign a weight to each vertex and each edge of the graph \xe2\x80\x94 an integer from 1 to 3.
An edge of the graph is called good if the bitwise XOR of the weights of its adjacent vertices is not equal to 0 and not equal to the weight of that edge.
Similarly, a vertex of the graph is called good if the bitwise XOR of the weights of its adjacent edges is not equal to 0 and not equal to the weight of that vertex.
You need to determine how many ways there are to assign weights to the vertices and edges of the graph so that all vertices and edges are good. Since the answer can be quite large, you need to calculate the remainder of the answer divided by 998244353.
The first line contains two integers n and m \xe2\x80\x94 the number of vertices and the number of edges in the graph (2\xe2\x89\xa4n\xe2\x89\xa45\xe2\x8b\x85105, n\xe2\x88\x921\xe2\x89\xa4m\xe2\x89\xa4106).
Each of the next m lines contains three integers ai,bi, and di (1\xe2\x89\xa4ai,bi\xe2\x89\xa4n, ai\xe2\x89\xa0bi, 0\xe2\x89\xa4di\xe2\x89\xa4109), indicating that there is an edge in the graph connecting vertices ai and bi. Additionally, on this edge, there are di additional vertices. It is guaranteed that the given graph is connected, there are no multiple edges, loops, and any two distinct simple cycles of the graph do not have common vertices.
Output a single integer \xe2\x80\x94 the answer to the problem modulo 998244353.
In the first test, the graph is a simple cycle of 3 vertices. It can be shown, that there are exactly 12 ways to assign weights, to make all vertexes and edges good.
In the second test, the graph has the form of two simple cycles of 3 vertices connected by an edge. It can be shown that for such a graph there are no ways to arrange weights so that all vertices and edges are good." "3500  x198"
1893D "Colorful Constructive" "constructive algorithms, data structures, greedy" "You have nn colored cubes, the ii-th cube has color aiai.
You need to distribute all the cubes on shelves. There are a total of mm shelves, the ii-th shelf can hold sisi cubes. Also, s1+s2+\xe2\x80\xa6+sm=ns1+s2+\xe2\x80\xa6+sm=n.
Suppose on a shelf of size k there are cubes of colors c1,c2,\xe2\x80\xa6,ck, in this order. Then we define the colorfulness of the shelf as the minimum distance between two different cubes of the same color on the shelf. If all the cubes on the shelf have different colors, then the colorfulness is considered to be equal to the size of the shelf, that is, the number k.
More formally, the colorfulness of c1,c2,\xe2\x80\xa6,ck is defined as follows:
For each shelf, you are given the minimum required colorfulness, that is, you are given numbers d1,d2,\xe2\x80\xa6,dm, which mean that shelf i must have a colorfulness \xe2\x89\xa5di for all i.
Distribute the available cubes among the shelves to ensure the required colorfulness, or report that it is impossible.
Each test contains multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers n,m (1\xe2\x89\xa4m\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of cubes and the number of shelves to distribute them to.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4n) \xe2\x80\x94 the colors of the cubes.
The third line of each test case contains m integers s1,s2,\xe2\x80\xa6,sm (1\xe2\x89\xa4si\xe2\x89\xa4n) \xe2\x80\x94 the sizes of the shelves. It\'s guaranteed, that s1+\xe2\x80\xa6+sm=n.
The fourth line of each test case contains m integers d1,d2,\xe2\x80\xa6,dm (1\xe2\x89\xa4di\xe2\x89\xa4si) \xe2\x80\x94 the minimum required colorfulness of the shelves.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, if it is impossible to distribute the cubes on the shelves satisfying all the requirements, output a single number \xe2\x88\x921. Otherwise, output m lines, where the i-th line should contain si numbers representing the colors of the cubes on the i-th shelf, in the appropriate order." "2600  x930"
1893C "Freedom of Choice" "brute force, greedy, implementation" "Let\'s define the anti-beauty of a multiset {b1,b2,\xe2\x80\xa6,blen}{b1,b2,\xe2\x80\xa6,blen} as the number of occurrences of the number lenlen in the multiset.
You are given mm multisets, where the ii-th multiset contains ni distinct elements, specifically: ci,1 copies of the number ai,1, ci,2 copies of the number ai,2,\xe2\x80\xa6,ci,ni copies of the number ai,ni. It is guaranteed that ai,1<ai,2<\xe2\x80\xa6<ai,ni. You are also given numbers l1,l2,\xe2\x80\xa6,lm and r1,r2,\xe2\x80\xa6,rm such that 1\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa4ci,1+\xe2\x80\xa6+ci,ni.
Let\'s create a multiset X, initially empty. Then, for each i from 1 to m, you must perform the following action exactly once:
You need to choose v1,\xe2\x80\xa6,vm and the added numbers in such a way that the resulting multiset X has the minimum possible anti-beauty.
Each test consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer m (1\xe2\x89\xa4m\xe2\x89\xa4105) \xe2\x80\x94 the number of given multisets.
Then, for each i from 1 to m, a data block consisting of three lines is entered.
The first line of each block contains three integers ni,li,ri (1\xe2\x89\xa4ni\xe2\x89\xa4105,1\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa4ci,1+\xe2\x80\xa6+ci,ni\xe2\x89\xa41017) \xe2\x80\x94 the number of distinct numbers in the i-th multiset and the limits on the number of elements to be added to X from the i-th multiset.
The second line of the block contains ni integers ai,1,\xe2\x80\xa6,ai,ni (1\xe2\x89\xa4ai,1<\xe2\x80\xa6<ai,ni\xe2\x89\xa41017) \xe2\x80\x94 the distinct elements of the i-th multiset.
The third line of the block contains ni integers ci,1,\xe2\x80\xa6,ci,ni (1\xe2\x89\xa4ci,j\xe2\x89\xa41012) \xe2\x80\x94 the number of copies of the elements in the i-th multiset.
It is guaranteed that the sum of the values of m for all test cases does not exceed 105, and also the sum of ni for all blocks of all test cases does not exceed 105.
For each test case, output the minimum possible anti-beauty of the multiset X that you can achieve.
In the first test case, the multisets have the following form:
You can select the elements {10,11,11,11,12} from the first multiset, {12} from the second multiset, and {13,13,13,13} from the third multiset. Thus, X={10,11,11,11,12,12,13,13,13,13}. The size of X is 10, the number 10 appears exactly 1 time in X, so the anti-beauty of X is 1. It can be shown that it is not possible to achieve an anti-beauty less than 1." "2000  x2738"
1893B "Neutral Tonality" "constructive algorithms, greedy, sortings, two pointers" "You are given an array aa consisting of nn integers, as well as an array bb consisting of mm integers.
Let LIS(c)LIS(c) denote the length of the longest increasing subsequence of array cc. For example, LIS([2,1_,1,3_])LIS([2,1\xe2\x80\x93,1,3\xe2\x80\x93]) = 2, LIS([1_,7_,9_]) = 3, LIS([3,1_,2_,4_]) = 3.
You need to insert the numbers b1,b2,\xe2\x80\xa6,bm into the array a, at any positions, in any order. Let the resulting array be c1,c2,\xe2\x80\xa6,cn+m. You need to choose the positions for insertion in order to minimize LIS(c).
Formally, you need to find an array c1,c2,\xe2\x80\xa6,cn+m that simultaneously satisfies the following conditions:
Each test contains multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers n,m (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105,1\xe2\x89\xa4m\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the length of array a and the length of array b.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4109) \xe2\x80\x94 the elements of the array a.
The third line of each test case contains m integers b1,b2,\xe2\x80\xa6,bm (1\xe2\x89\xa4bi\xe2\x89\xa4109) \xe2\x80\x94 the elements of the array b.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105, and the sum of m over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output n+m numbers \xe2\x80\x94 the elements of the final array c1,c2,\xe2\x80\xa6,cn+m, obtained after the insertion, such that the value of LIS(c) is minimized. If there are several answers, you can output any of them.
In the first test case, LIS(a)=LIS([6,4])=1. We can insert the number 5 between 6 and 4, then LIS(c)=LIS([6,5,4])=1.
In the second test case, LIS([1_,7,2_,4_,5_]) = 4. After the insertion, c=[1,1,7,7,2,2,4,4,5,5]. It is easy to see that LIS(c)=4. It can be shown that it is impossible to achieve LIS(c) less than 4." "1700  x9015"
1893A "Anonymous Informant" "brute force, dfs and similar, graphs, implementation" "You are given an array b1,b2,\xe2\x80\xa6,bn.
An anonymous informant has told you that the array b was obtained as follows: initially, there existed an array a1,a2,\xe2\x80\xa6,an, after which the following two-component operation was performed k times:
As a result of k such operations, the array b1,b2,\xe2\x80\xa6,bn was obtained. You want to check if the words of the anonymous informant can be true or if they are guaranteed to be false.
\xe2\x80\xa0A number x is called a fixed point of the array a1,a2,\xe2\x80\xa6,an if 1\xe2\x89\xa4x\xe2\x89\xa4n and ax=x.
\xe2\x80\xa1A cyclic left shift of the array a1,a2,\xe2\x80\xa6,an is the array a2,\xe2\x80\xa6,an,a1.
Each test contains multiple test cases. The first line contains an integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers n,k (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 1\xe2\x89\xa4k\xe2\x89\xa4109) \xe2\x80\x94 the length of the array b and the number of operations performed.
The second line of each test case contains n integers b1,b2,\xe2\x80\xa6,bn (1\xe2\x89\xa4bi\xe2\x89\xa4109) \xe2\x80\x94 the elements of the array b.
It is guaranteed that the sum of the values of n for all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output ""Yes"" if the words of the anonymous informant can be true, and ""No"" if they are guaranteed to be false.
In the first test case, the array a could be equal to [3,2,3,4,3]. In the first operation, a fixed point x=2 was chosen, and after 2 left shifts, the array became [3,4,3,3,2]. In the second operation, a fixed point x=3 was chosen, and after 3 left shifts, the array became [3,2,3,4,3]. In the third operation, a fixed point x=3 was chosen again, and after 3 left shifts, the array became [4,3,3,2,3], which is equal to the array b.
In the second test case, the array a could be equal to [7,2,1]. After the operation with a fixed point x=2, the array became [1,7,2]. Then, after the operation with a fixed point x=1, the array returned to its initial state [7,2,1]. These same 2 operations (with x=2, and x=1) were repeated 49 times. So, after 100 operations, the array returned to [7,2,1].
In the third test case, it can be shown that there is no solution." "1400  x12528"
1891F "A Growing Tree" "data structures, dfs and similar, trees" "You are given a rooted tree with the root at vertex 1, initially consisting of a single vertex. Each vertex has a numerical value, initially set to 0. There are also q queries of two types: 
After all queries, output the numerical value of all of the vertices in the final tree.
The first line contains a single integer T (1\xe2\x89\xa4T\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The descriptions of the test cases follow.
The first line of each test case contains a single integer q (1\xe2\x89\xa4q\xe2\x89\xa45\xe2\x8b\x85105) \xe2\x80\x94 the number of queries.
The following q lines can fall into two cases: 
It is guaranteed that the sum of q across all test cases does not exceed 5\xe2\x8b\x85105.
For each test case, output the numerical value of each vertex of the final tree after all queries have been performed.
In the first case, the final tree with the assigned numerical values will look like this: " "2000  x3864"
1891E "Brukhovich and Exams" "brute force, greedy, implementation, math, sortings" "The boy Smilo is learning algorithms with a teacher named Brukhovich.
Over the course of the year, Brukhovich will administer nn exams. For each exam, its difficulty ai is known, which is a non-negative integer.
Smilo doesn\'t like when the greatest common divisor of the difficulties of two consecutive exams is equal to 1. Therefore, he considers the sadness of the academic year to be the number of such pairs of exams. More formally, the sadness is the number of indices i (1\xe2\x89\xa4i\xe2\x89\xa4n\xe2\x88\x921) such that gcd(ai,ai+1)=1, where gcd(x,y) is the greatest common divisor of integers x and y.
Brukhovich wants to minimize the sadness of the year of Smilo. To do this, he can set the difficulty of any exam to 0. However, Brukhovich doesn\'t want to make his students\' lives too easy. Therefore, he will perform this action no more than k times.
Help Smilo determine the minimum sadness that Brukhovich can achieve if he performs no more than k operations.
As a reminder, the greatest common divisor (GCD) of two non-negative integers x and y is the maximum integer that is a divisor of both x and y and is denoted as gcd(x,y). In particular, gcd(x,0)=gcd(0,x)=x for any non-negative integer x.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The descriptions of the test cases follow.
The first line of each test case contains two integers n and k (1\xe2\x89\xa4k\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 the total number of exams and the maximum number of exams that can be simplified, respectively. 
The second line of each test case contains n integers a1,a2,a3,\xe2\x80\xa6,an \xe2\x80\x94 the elements of array a, which are the difficulties of the exams (0\xe2\x89\xa4ai\xe2\x89\xa4109).
It is guaranteed that the sum of n across all test cases does not exceed 105.
For each test case, output the minimum possible sadness that can be achieved by performing no more than k operations.
In the first test case, a sadness of 1 can be achieved. To this, you can simplify the second and fourth exams. After this, there will be only one pair of adjacent exams with a greatest common divisor (GCD) equal to one, which is the first and second exams.
In the second test case, a sadness of 0 can be achieved by simplifying the second and fourth exams." "2500  x852"
1891D "Suspicious logarithms" "binary search, brute force, math" "Let f(x) be the floor of the binary logarithm of x. In other words, f(x) is largest non-negative integer y, such that 2y does not exceed x.
Let g(x) be the floor of the logarithm of x with base f(x). In other words, g(x) is the largest non-negative integer z, such that f(x)z does not exceed x.
You are given q queries. The i-th query consists of two integers li and ri. The answer to the query is the sum of g(k) across all integers k, such that li\xe2\x89\xa4k\xe2\x89\xa4ri. Since the answers might be large, print them modulo 109+7.
The first line contains a single integer q \xe2\x80\x94 the number of queries (1\xe2\x89\xa4q\xe2\x89\xa4105).
The next q lines each contain two integers li and ri \xe2\x80\x94 the bounds of the i-th query (4\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa41018). 
For each query, output the answer to the query modulo 109+7.
The table below contains the values of the functions f(x) and g(x) for all x such that 1\xe2\x89\xa4x\xe2\x89\xa48. " "1900  x4011"
1891C "Smilo and Monsters" "binary search, constructive algorithms, greedy, sortings, two pointers" "A boy called Smilo is playing a new game! In the game, there are n hordes of monsters, and the i-th horde contains ai monsters. The goal of the game is to destroy all the monsters. To do this, you have two types of attacks and a combo counter x, initially set to 0:
Your task is to destroy all of the monsters, meaning that there should be no monsters left in any of the hordes. Smilo wants to win as quickly as possible, so he wants to the minimum number of attacks required to win the game. 
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The descriptions of the test cases follow.
The first line of each input data set contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of hordes of monsters.
The second line contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4109) \xe2\x80\x94 the number of monsters in each horde.
It is guaranteed that the sum of n across all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, out put the minimum number of attacks required to kill all monsters.
In the first test case, we can use an attack of the first type on the 1-st, 3-rd and 4-th hordes, and then use an attack of the second type to finish off the 2-nd horde. We need 4 attacks in total.
In the second test case, we can use an attack of the first type on the 1-st and 3-rd hordes, then use an attack of the second type to finish off the 2-nd horde, and then use an attack of the first type on the 4-th horde. We need 4 attacks in total.
In the fourth test case, we can use an attack of the first type once on the 1-st horde, twice on the 2-nd horde, and then use an attack of the second type on the 2-nd horde, and finally use an attack of the first type to finish off the 2-nd horde. We need 5 attacks in total." "1500  x13572"
1891B "Deja Vu" "brute force, math, sortings" "You are given an array a of length n, consisting of positive integers, and an array x of length q, also consisting of positive integers.
There are q modification. On the i-th modification (1\xe2\x89\xa4i\xe2\x89\xa4q), for each j (1\xe2\x89\xa4j\xe2\x89\xa4n), such that aj is divisible by 2xi, you add 2xi\xe2\x88\x921 to aj. Note that xi (1\xe2\x89\xa4xi\xe2\x89\xa430) is a positive integer not exceeding 30.
After all modification queries, you need to output the final array.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers n and q (1\xe2\x89\xa4n,q\xe2\x89\xa4105) \xe2\x80\x94the length of the array a and the number of queries respectively.
The second line of each test case contains n integers a1,a2,a3,\xe2\x80\xa6,an \xe2\x80\x94 the elements of the array a (1\xe2\x89\xa4ai\xe2\x89\xa4109).
The third line of each test case contains q integers x1,x2,x3,\xe2\x80\xa6,xq \xe2\x80\x94 the elements of the array x (1\xe2\x89\xa4xi\xe2\x89\xa430), which are the modification queries.
It is guaranteed that the sum of n and the sum of q across all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output the array after all of the modification queries.
In the first test case, the first query will add 2 to the integers in positions 4 and 5. After this addition, the array would be [1,2,3,6,6]. Other operations will not modify the array.
In the second test case, the first modification query does not change the array. The second modification query will add 8 to the integer in position 5, so that the array would look like this: [7,8,12,36,56,6,3]. The third modification query will add 2 to the integers in positions 2,3, 4 and 5. The array would then look like this: [7,10,14,38,58,6,3]." "1100  x18407"
1891A "Sorting with Twos" "constructive algorithms, sortings" "You are given an array of integers a1,a2,\xe2\x80\xa6,an. In one operation, you do the following: 
Can you sort the array in non-decreasing order by performing some number (possibly zero) of operations?
An array is considered non-decreasing if ai\xe2\x89\xa4ai+1 for all integers i such that 1\xe2\x89\xa4i\xe2\x89\xa4n\xe2\x88\x921.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa420) \xe2\x80\x94 the length of array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an \xe2\x80\x94 the integers in array a (0\xe2\x89\xa4ai\xe2\x89\xa41000).
For each test case, output ""YES"" if the array can be sorted, and ""NO"" otherwise.
In the first test case, the array is already sorted in non-decreasing order, so we don\'t have to perform any operations.
In the second test case, we can choose m=1 twice to get the array [4,3,3,4,4]. Then, we can choose m=0 once and get the sorted in non-decreasing order array [3,3,3,4,4].
In the third test case, we can choose m=0 once and get the array [5,5,5,7,5,6,6,8,7]. Then, we can choose m=2 twice and get the array [3,3,3,5,5,6,6,8,7]. After that, we can choose m=3 once and get the sorted in non-decreasing order array [2,2,2,4,4,5,5,7,7].
For the fourth and fifth test case, it can be shown that the array could not be sorted using these operations." "800  x19332"
1890B "Qingshan Loves Strings" "constructive algorithms, implementation" "Qingshan has a string s, while Daniel has a string t. Both strings only contain 0 and 1.
A string a of length k is good if and only if
For example, 1, 101, 0101 are good, while 11, 1001, 001100 are not good.
Qingshan wants to make s good. To do this, she can do the following operation any number of times (possibly, zero):
Please tell Qingshan if it is possible to make s good.
The input consists of multiple test cases. The first line contains a single integer T (1\xe2\x89\xa4T\xe2\x89\xa42000) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers n and m (1\xe2\x89\xa4n,m\xe2\x89\xa450) \xe2\x80\x94 the length of the strings s and t, respectively.
The second line of each test case contains a string s of length n.
The third line of each test case contains a string t of length m.
It is guaranteed that s and t only contain 0 and 1.
For each test case, print ""YES"" (without quotes), if it is possible to make s good, and ""NO"" (without quotes) otherwise.
You can print letters in any case (upper or lower).
In the first test case, s is good initially, so you can get a good s by doing zero operations.
In the second test case, you can do the following two operations (the inserted string t is underlined):
and get s=101010101, which is good.
In the third test case, there is no way to make s good after any number of operations." "800  x17608"
1890A "Doremy's Paint 3" "constructive algorithms" "An array b1,b2,\xe2\x80\xa6,bn of positive integers is good if all the sums of two adjacent elements are equal to the same value. More formally, the array is good if there exists a k such that b1+b2=b2+b3=\xe2\x80\xa6=bn\xe2\x88\x921+bn=k.
Doremy has an array a of length n. Now Doremy can permute its elements (change their order) however she wants. Determine if she can make the array good.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4100) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer n (2\xe2\x89\xa4n\xe2\x89\xa4100) \xe2\x80\x94 the length of the array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4105).
There are no constraints on the sum of n over all test cases.
For each test case, print ""Yes"" (without quotes), if it is possible to make the array good, and ""No"" (without quotes) otherwise.
You can output the answer in any case (upper or lower). For example, the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as positive responses.
In the first test case, [8,9] and [9,8] are good.
In the second test case, [1,2,1] is good because a1+a2=a2+a3=3.
In the third test case, it can be shown that no permutation is good." "800  x27753"
1889F "Doremy's Average Tree" "data structures, dp, greedy, trees" "Doremy has a rooted tree of size nn whose root is vertex r. Initially there is a number wi written on vertex i. Doremy can use her power to perform this operation at most k times:
Doremy wants to know what is the lexicographically smallest\xe2\x80\xa0 array w after performing all the operations. Can you help her?
If there are multiple answers, you may output any one.
\xe2\x80\xa0 For arrays a and b both of length n, a is lexicographically smaller than b if and only if there exist an index i (1\xe2\x89\xa4i\xe2\x89\xa4n) such that ai<bi and for all indices j such that j<i, aj=bj is satisfied.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line contains three integers n, r, k (2\xe2\x89\xa4n\xe2\x89\xa45000, 1\xe2\x89\xa4r\xe2\x89\xa4n, 0\xe2\x89\xa4k\xe2\x89\xa4min(500,n)).
The second line contains n integers w1,w2,\xe2\x80\xa6,wn (1\xe2\x89\xa4wi\xe2\x89\xa4106).
Each of the next n\xe2\x88\x921 lines contains two integers ui, vi (1\xe2\x89\xa4ui,vi\xe2\x89\xa4n), representing an edge between ui and vi.
It is guaranteed that the given edges form a tree.
It is guaranteed that the sum of n does not exceed 50000.
For each test case, In the first line, output a single integer cnt (0\xe2\x89\xa4cnt\xe2\x89\xa4k) \xe2\x80\x94 the number of operations you perform.
Then, in the second line output cnt integers p1,p2,\xe2\x80\xa6,pcnt \xe2\x80\x94 x is chosen to be pi for i-th operation.
If there are multiple answers, you may output any one.
In the first test case:

At first w=[1,9,2,6,1,8]. You can choose some vertex x to perform at most one operation.
w is lexicographically smallest when x=2." "3500  x82"
1889E "Doremy's Swapping Trees" "dfs and similar, graphs, trees" "Consider two undirected graphs G1G1 and G2G2. Every node in G1G1 and in G2G2 has a label. Doremy calls G1G1 and G2 similar if and only if:
Now Doremy gives you two trees T1 and T2 with n nodes, labeled from 1 to n. You can do the following operation any number of times:
Now Doremy is wondering how many distinct T1 you can get after any number of operations. Can you help her find the answer? Output the answer modulo 109+7.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa42\xe2\x8b\x85104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line contains an integer n (2\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 the number of nodes in the trees T1 and T2.
Each of the following n\xe2\x88\x921 lines contain two integers u,v (1\xe2\x89\xa4u,v\xe2\x89\xa4n), representing an undirected edge in T1. It is guaranteed these edges form a tree.
Each of the following n\xe2\x88\x921 lines contain two integers u,v (1\xe2\x89\xa4u,v\xe2\x89\xa4n), representing an undirected edge in T2. It is guaranteed these edges form a tree.
It is guaranteed that the sum of n does not exceed 2\xe2\x8b\x85105.
For each test case, you should output a single line with an integer, representing the number of distinct T1 after any number of operations, modulo 109+7.
In the first test case, there is at most one distinct T1 having the only edge (1,2).
In the second test case, you can choose the edge set {(1,3),(2,3)} in T1, the edge set {(1,2),(2,3)} in T2 and swap them. So T1 can be 1\xe2\x88\x923\xe2\x88\x922 or 1\xe2\x88\x922\xe2\x88\x923.
In the third test case, there are 4 distinct T1, as the following pictures.
" "3500  x112"
1889D "Game of Stacks" "brute force, dfs and similar, graphs, implementation, trees" "You have n stacks r1,r2,\xe2\x80\xa6,rn. Each stack contains some positive integers ranging from 1 to n.
Define the following functions:
You want to know the values returned by init(1),init(2),\xe2\x80\xa6,init(n).
Note that, during these calls, the stacks r1,r2,\xe2\x80\xa6,rn don\'t change, so the calls init(1),init(2),\xe2\x80\xa6,init(n) are independent.
The first line of the input contains one integer n (1\xe2\x89\xa4n\xe2\x89\xa4105) \xe2\x80\x94 the length of the array r.
Each of the following n lines contains several integers. The first integer ki (0\xe2\x89\xa4ki\xe2\x89\xa4105) represents the number of elements in the i-th stack, and the following ki positive integers ci,1,ci,2,\xe2\x80\xa6,ci,ki (1\xe2\x89\xa4ci,j\xe2\x89\xa4n) represent the elements in the i-th stack. ci,1 is the bottom element.
In each test, \xe2\x88\x91ki\xe2\x89\xa4106.
You need to output n values, the i-th of which is the value returned by init(i).
In the first example: " "3000  x621"
1889C2 "Doremy's Drying Plan (Hard Version)" "data structures, dp" "The only differences between the two versions of this problem are the constraint on kk, the time limit and the memory limit. You can make hacks only if all versions of the problem are solved.
Doremy lives in a rainy country consisting of n cities numbered from 1 to n.
The weather broadcast predicted the distribution of rain in the next m days. In the i-th day, it will rain in the cities in the interval [li,ri]. A city is called dry if it will never rain in that city in the next m days.
It turns out that Doremy has a special power. She can choose k days, and during these days it will not rain. Doremy wants to calculate the maximum number of dry cities after using the special power.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line contains three integers n, m and k (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 2\xe2\x89\xa4m\xe2\x89\xa42\xe2\x8b\x85105, 2\xe2\x89\xa4k\xe2\x89\xa4min(10,m)) \xe2\x80\x94 the number of cities, the number of days, and the number of days of rain that Doremy can prevent.
Then, m lines follow. The i-th line contains two integers li, ri (1\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa4n) \xe2\x80\x94 the rain coverage on day i.
It is guaranteed that the sum of n and the sum of m over all test cases do not exceed 2\xe2\x8b\x85105.
For each test case, output one integer \xe2\x80\x94 the maximum number of dry cities.
In the first test case, if Doremy prevents
So there is at most 1 dry city.
In the second test case, if Doremy prevents
So there are at most 2 dry cities.
In the third test case, it is optimal to prevent rain 1,2,4,5.
In the forth test case, there is always a day of rain that wets all the cities and cannot be prevented." "2600  x1011"
1889C1 "Doremy's Drying Plan (Easy Version)" "brute force, data structures, dp, greedy, sortings" "The only differences between the two versions of this problem are the constraint on kk, the time limit and the memory limit. You can make hacks only if all versions of the problem are solved.
Doremy lives in a rainy country consisting of n cities numbered from 1 to n.
The weather broadcast predicted the distribution of rain in the next m days. In the i-th day, it will rain in the cities in the interval [li,ri]. A city is called dry if it will never rain in that city in the next m days.
It turns out that Doremy has a special power. She can choose k days (in the easy version, k=2), and during these days it will not rain. Doremy wants to calculate the maximum number of dry cities after using the special power.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line contains three integers n, m and k (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 2\xe2\x89\xa4m\xe2\x89\xa42\xe2\x8b\x85105, k=2) \xe2\x80\x94 the number of cities, the number of days, and the number of days of rain that Doremy can prevent.
Then, m lines follow. The i-th line contains two integers li, ri (1\xe2\x89\xa4li\xe2\x89\xa4ri\xe2\x89\xa4n) \xe2\x80\x94 the rain coverage on day i.
It is guaranteed that the sum of n and the sum of m over all test cases do not exceed 2\xe2\x8b\x85105.
For each test case, output one integer \xe2\x80\x94 the maximum number of dry cities.
In the first test case, if Doremy prevents
So there is at most 1 dry city.
In the second test case, if Doremy prevents
So there are at most 2 dry cities.
In the third test case, it is optimal to prevent rain 2,5.
In the forth test case, there is always 4 days of rain that wets all the cities and cannot be prevented." "2000  x3326"
1889B "Doremy's Connecting Plan" "constructive algorithms, greedy, math, sortings" "Doremy lives in a country consisting of nn cities numbered from 1 to n, with ai people living in the i-th city. It can be modeled as an undirected graph with n nodes.
Initially, there are no edges in the graph. Now Doremy wants to make the graph connected. 
To do this, she can add an edge between i and j if 
\xe2\x88\x91k\xe2\x88\x88Sak\xe2\x89\xa5i\xe2\x8b\x85j\xe2\x8b\x85c,
where S is the set of all the nodes that are currently in the same connected component of either i or j, and c is a given constant.
Can Doremy make the graph connected?
Two nodes (i,j) are in the same connected component if there exists a path from i to j. A graph is connected if all its nodes are in the same connected component.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line contains two integers n, c (2\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105, 1\xe2\x89\xa4c\xe2\x89\xa4106) \xe2\x80\x94 the number of nodes and the constant.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (0\xe2\x89\xa4ai\xe2\x89\xa41012) \xe2\x80\x94 the number of people living in the i-th city.
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, print ""YES"" (without quotes), if it is possible to make the graph connected, and ""NO"" (without quotes) otherwise.
You can print letters in any case (upper or lower).
In the first test case, Doremy can add edges in the following order:
In the second test case, Doremy can add edge (1,2) because a1+a2=2\xe2\x89\xa51\xe2\x8b\x852\xe2\x8b\x851. After that, the graph is connected.
In the third test case, Doremy can add edges in the order (5,4), (5,3), (5,2) and (5,1).
In the fourth test case, Doremy cannot add any edge at all." "1700  x7468"
1889A "Qingshan Loves Strings 2" "constructive algorithms, greedy, implementation" "Qingshan has a string ss which only contains 0 and 1.
A string a of length k is good if and only if
For Div. 2 contestants, note that this condition is different from the condition in problem B.
For example, 10, 1010, 111000 are good, while 11, 101, 001, 001100 are not good.
Qingshan wants to make s good. To do this, she can do the following operation at most 300 times (possibly, zero): 
Please tell Qingshan if it is possible to make s good. If it is possible, print a sequence of operations that makes s good.
The input consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4100) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa4100) \xe2\x80\x94 the length of string s, respectively.
The second line of each test case contains a string s with length n.
It is guaranteed that s only consists of 0 and 1.
For each test case, if it impossible to make s good, output \xe2\x88\x921.
Otherwise, output p (0\xe2\x89\xa4p\xe2\x89\xa4300) \xe2\x80\x94 the number of operations, in the first line.
Then, output p integers in the second line. The i-th integer should be an index xi (0\xe2\x89\xa4xi\xe2\x89\xa4n+2i\xe2\x88\x922) \xe2\x80\x94 the position where you want to insert 01 in the current s. If xi=0, you insert 01 at the beginning of s. Otherwise, you insert 01 immediately after the xi-th character of s.
We can show that under the constraints in this problem, if an answer exists, there is always an answer that requires at most 300 operations.
In the first test case, you can do zero operations and get s=01, which is good.
Another valid solution is to do one operation: (the inserted 01 is underlined)
and get s=0011, which is good.
In the second and the third test case, it is impossible to make s good.
In the fourth test case, you can do two operations:
and get s=0011100011, which is good." "1300  x13347"
1887F "Minimum Segments" "constructive algorithms" "You had a sequence a1,a2,\xe2\x80\xa6,an consisting of integers from 1 to n, not necessarily distinct. For some unknown reason, you decided to calculate the following characteristic of the sequence: 
Each test consist of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases. The description of test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the length of the lost sequence a.
The second line of each test case contains n integers r1,r2,\xe2\x80\xa6,rn (i\xe2\x89\xa4ri\xe2\x89\xa4n+1) \xe2\x80\x94 the characteristic of the lost sequence a. 
It is guaranteed that the sum of n over all test cases does not exceed 2\xe2\x8b\x85105.
For each test case, output the following: 
In the first test case, the sequence a=[1,2,1] is suitable. The integers 1 and 2 appear on the subsegments [1,2] and [2,3].
In the second test case, it can be proved that there is no suitable sequence a." "3400  x174"
1887E "Good Colorings" "binary search, constructive algorithms, graphs, interactive" "Alice suggested Bob to play a game. Bob didn\'t like this idea, but he couldn\'t refuse Alice, so he asked you to write a program that would play instead of him.
The game starts with Alice taking out a grid sheet of size n\xc3\x97n, the cells of which are initially not colored. After that she colors some 2n cells with colors 1,2,\xe2\x80\xa6,2n, respectively, and informs Bob about these cells.
In one move, Bob can point to a cell that has not been colored yet and ask Alice to color that cell. Alice colors that cell with one of the 2n colors of her choice, informing Bob of the chosen color. Bob can make no more than 10 moves, after which he needs to find a good set of four cells.
A set of four cells is considered good if the following conditions are met:
Each test consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4200) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer n (3\xe2\x89\xa4n\xe2\x89\xa41000) \xe2\x80\x94 the size of the grid.
The i-th of the following 2n lines contains two integers xi and yi (1\xe2\x89\xa4xi,yi\xe2\x89\xa4n) \xe2\x80\x94 the coordinates of the cell colored with the i-th color.
It is guaranteed that all coordinates (xi,yi) are pairwise distinct for the same test case.
After reading the input data for each test case, continue the interaction as described below.
You can make no more than 10 moves. To make a move, output ""? x y"" (1\xe2\x89\xa4x,y\xe2\x89\xa4n). In response to this, the jury\'s program will output a single integer from 1 to 2n \xe2\x80\x94 the color of cell (x,y).
After all moves (it is not necessary to make all 10 moves and it is not necessary to make at least one move), output a string in the format ""! x1 x2 y1 y2"" (1\xe2\x89\xa4x1,x2,y1,y2\xe2\x89\xa4n,x1\xe2\x89\xa0x2,y1\xe2\x89\xa0y2). If cells (x1,y1), (x1,y2), (x2,y1), (x2,y2) are colored with different colors, the jury\'s program will output ""OK"". After that, proceed to the next test case or terminate the program if there are no more test cases left.
Otherwise, if any of the specified cells are colored with the same color or one of the cells is not colored yet, the jury\'s program will output ""ERROR"". In this case, your program should immediately terminate its execution to receive the Wrong Answer verdict. Otherwise, you may receive an arbitrary verdict.
After each move or answer, do not forget to output the end of line and flush the output. Otherwise, you will get the Idleness limit exceeded verdict.
To do this, use:
Note that the interactor is adaptive, meaning that the color Alice will use to color the cells during Bob\'s moves is not fixed in advance.
Hacks
You cannot use hacks in this problem.
In the first test case:
In the second test case, cells with coordinates (1,1),(1,2),(2,1),(2,2) are initially colored by Alice in different colors." "3100  x384"
1887D Split "binary search, data structures, divide and conquer, dsu, math, trees, two pointers" "Let\'s call an array b1,b2,\xe2\x80\xa6,bm (m\xe2\x89\xa52) good if it can be split into two parts such that all elements in the left part are strictly smaller than all elements in the right part. In other words, there must exist an index 1\xe2\x89\xa4i<m such that every element from b1,\xe2\x80\xa6,bi is strictly smaller than every element from bi+1,\xe2\x80\xa6,bm.
Given an array a1,a2,\xe2\x80\xa6an consisting of distinct integers from 1 to n. There are q queries. Each query consists of two numbers l and r. For each query, determine whether the array al,al+1,\xe2\x80\xa6,ar is good.
The first line contains a single integer n (2\xe2\x89\xa4n\xe2\x89\xa43\xe2\x8b\x85105) \xe2\x80\x94 the size of the array.
The second line contains n distinct integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4an\xe2\x89\xa4n) \xe2\x80\x94 the elements of the array a.
The third line contains a single integer q (1\xe2\x89\xa4q\xe2\x89\xa43\xe2\x8b\x85105) \xe2\x80\x94 the number of queries.
Each of the next q lines contains two integers li and ri (1\xe2\x89\xa4li<ri\xe2\x89\xa4n) \xe2\x80\x94 the description of the i-th query.
For each query, output ""Yes"" (without quotes) if the array al,al+1,\xe2\x80\xa6,ar is good, and ""No"" (without quotes) otherwise.
You can output ""Yes"" and ""No"" in any case (for example, the strings ""yEs"", ""yes"", ""Yes"", and ""YES"" will be recognized as a positive answer).
In the first example:
In the second example:" "2700  x979"
1887C "Minimum Array" "binary search, brute force, constructive algorithms, data structures, greedy, hashing, two pointers" "Given an array a of length n consisting of integers. Then the following operation is sequentially applied to it q times:
Let bj be the array a obtained after applying the first j operations (0\xe2\x89\xa4j\xe2\x89\xa4q). Note that b0 is the array a before applying any operations.
You need to find the lexicographically minimum\xe2\x80\xa0 array among all arrays bj.
\xe2\x80\xa0An array x is lexicographically smaller than array y if there is an index i such that xi<yi, and xj=yj for all j<i. In other words, for the first index i where the arrays differ, xi<yi.
Each test consists of multiple test cases. The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa45\xe2\x8b\x85105) \xe2\x80\x94 the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa45\xe2\x8b\x85105) \xe2\x80\x94 the length of array a.
The second line of each test case contains n integers a1,a2,\xe2\x80\xa6,an (\xe2\x88\x92109\xe2\x89\xa4ai\xe2\x89\xa4109) \xe2\x80\x94 the elements of array a.
The third line of each test case contains a single integer q (0\xe2\x89\xa4q\xe2\x89\xa45\xe2\x8b\x85105) \xe2\x80\x94 the number of operations on the array.
In each of the next q lines, there are three integers lj, rj, and xj (1\xe2\x89\xa4lj\xe2\x89\xa4rj\xe2\x89\xa4n,\xe2\x88\x92109\xe2\x89\xa4xj\xe2\x89\xa4109) \xe2\x80\x94 the description of each operation. The operations are given in the order they are applied.
It is guaranteed that the sum of n over all test cases and the sum of q over all test cases do not exceed 5\xe2\x8b\x85105.
For each test case, output the lexicographically minimum array among all arrays bj.
In the first test case:
Thus, the lexicographically minimum array is b2.
In the second test case, the lexicographically minimum array is b0." "2400  x1772"
1887B "Time Travel" "binary search, graphs, shortest paths" "Berland is a country with ancient history, where roads were built and destroyed for centuries. It is known that there always were n cities in Berland. You also have records of t key moments in the history of the country, numbered from 1 to t. Each record contains a list of bidirectional roads between some pairs of cities, which could be used for travel in Berland at a specific moment in time.
You have discovered a time machine that transports you between key moments. Unfortunately, you cannot choose what point in time to end up at, but you know the order consisting of k moments in time ai, in which the machine will transport you. Since there is little time between the travels, when you find yourself in the next key moment in time (including after the last time travel), you can travel on at most one existing road at that moment, coming out from the city you were in before time travel.
Currently, you are in city 1, and the time machine has already transported you to moment a1. You want to reach city n as quickly as possible. Determine the minimum number of time travels, including the first one, that you need to make in order to reach city n.
The first line contains two integers n and t (2\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105,1\xe2\x89\xa4t\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of cities in Berland and the number of records about key moments in history. Then follows the description of each of the t records.
The first line of each record description contains a single integer mi (0\xe2\x89\xa4mi\xe2\x89\xa4min(n(n\xe2\x88\x921)2,2\xe2\x8b\x85105)) \xe2\x80\x94 the number of roads in the i-th record.
Each of the next mi lines contains two integers vj and uj (1\xe2\x89\xa4vj,uj\xe2\x89\xa4n, vj\xe2\x89\xa0uj) \xe2\x80\x94 the numbers of cities connected by the j-th road in the i-th key moment in history.
The next line contains a single integer k (1\xe2\x89\xa4k\xe2\x89\xa42\xe2\x8b\x85105) \xe2\x80\x94 the number of time moments between which movements will occur.
The next line contains k integers a1,a2,\xe2\x80\xa6,ak (1\xe2\x89\xa4ai\xe2\x89\xa4t) \xe2\x80\x94 the time moments at which you will be after each movement.
It is guaranteed that the sum of mi does not exceed 2\xe2\x8b\x85105. It is guaranteed that each unordered pair (u,v) occurs in the road description for one record no more than once.
Output a single integer \xe2\x80\x94 the minimum number of time travels required to reach city n from city 1, or \xe2\x88\x921 if it is impossible.
Note that movement to time moment a1 is also considered a movement.
In the first example, you are in city 1 and move to moment a1=2. Since there are no suitable roads to pass, you do nothing and move to moment a2=1, after which you travel along the road (1,2). Moving to moment a3=2, you travel along the road (2,3). Moving to moment a4=1, you stay in city 3 and make the next time travel. At time moment a5=2, you travel along the road (3,5) and end up in the final city after 5 time travels.
In the second example, it can be shown that it is impossible to reach city 5 with the given time travels." "1900  x3064"
1886F "Diamond Theft" "data structures, greedy" "Monocarp is the most famous thief in Berland. This time, he decided to steal two diamonds. Unfortunately for Monocarp, there are nn cameras monitoring the diamonds. Each camera has two parameters, ti and si. The first parameter determines whether the camera is monitoring the first diamond only (ti=1), the second diamond only (ti=2), or both diamonds (ti=3). The second parameter determines the number of seconds the camera will be disabled after it is hacked.
Every second, Monocarp can perform one of the following three actions: 
Note that Monocarp can hack a camera multiple times, even if it is currently disabled.
Your task is to determine the minimum time it will take Monocarp to steal both diamonds, beginning with the first diamond, or report that it is impossible.
The first line contains a single integer n (0\xe2\x89\xa4n\xe2\x89\xa41500) \xe2\x80\x94 the number of cameras.
Then n lines follow, the i-th of them contains two integers ti and si (1\xe2\x89\xa4ti\xe2\x89\xa43; 1\xe2\x89\xa4si\xe2\x89\xa42n) \xe2\x80\x94 the parameters of the i-th camera.
Print a single integer \xe2\x80\x94 the minimum time it will take for Monocarp to steal the first diamond first and then the second diamond. If it is impossible, print -1." "3300  x191"
1886E "I Wanna be the Team Leader" "bitmasks, constructive algorithms, dp, greedy, math, sortings, two pointers" "Monocarp is a team leader in a massive IT company.
There are m projects his team of programmers has to complete, numbered from 1 to m. The i-th project has a difficulty level bi.
There are n programmers in the team, numbered from 1 to n. The j-th programmer has a stress tolerance level aj.
Monocarp wants to assign the programmers to the projects in such a way that: 
Help Monocarp to find a valid assignment. If there are multiple answers, print any of them.
The first line contains two integers n and m (1\xe2\x89\xa4n\xe2\x89\xa42\xe2\x8b\x85105; 1\xe2\x89\xa4m\xe2\x89\xa420) \xe2\x80\x94 the number of programmers and the number of projects.
The second line contains n integers a1,a2,\xe2\x80\xa6,an (1\xe2\x89\xa4ai\xe2\x89\xa4109) \xe2\x80\x94 the stress tolerance level of each programmer.
The third line contains m integers b1,b2,\xe2\x80\xa6,bm (1\xe2\x89\xa4bi\xe2\x89\xa4109) \xe2\x80\x94 the difficulty level of each project.
If there is no valid assignment, print ""NO"".
Otherwise, in the first line, print ""YES"". In the i-th of the next m lines, print the list of the programmers assigned to the i-th project: first, the number of programmers, then their indices in an arbitrary order.
If there are multiple answers, print any of them." "2400  x1499"
1886D "Monocarp and the Set" "combinatorics, data structures, math" "Monocarp has nn numbers 1,2,\xe2\x80\xa6,n and a set (initially empty). He adds his numbers to this set n times in some order. During each step, he adds a new number (which has not been present in the set before). In other words, the sequence of added numbers is a permutation of length n.
Every time Monocarp adds an element into the set except for the first time, he writes out a character:
You are given a string s of n\xe2\x88\x921 characters, which represents the characters written out by Monocarp (in the order he wrote them out). You have to process m queries to the string. Each query has the following format:
Both before processing the queries and after each query, you have to calculate the number of different ways to order the integers 1,2,3,\xe2\x80\xa6,n such that, if Monocarp inserts the integers into the set in that order, he gets the string s. Since the answers might be large, print them modulo 998244353.
The first line contains two integers n and m (2\xe2\x89\xa4n\xe2\x89\xa43\xe2\x8b\x85105; 1\xe2\x89\xa4m\xe2\x89\xa43\xe2\x8b\x85105).
The second line contains the string s, consisting of exactly n\xe2\x88\x921 characters <, > and/or ?.
Then m lines follow. Each of them represents a query. Each line contains an integer i and a character c (1\xe2\x89\xa4i\xe2\x89\xa4n\xe2\x88\x921; c is either <, >, or ?).
Both before processing the queries and after each query, print one integer \xe2\x80\x94 the number of ways to order the integers 1,2,3,\xe2\x80\xa6,n such that, if Monocarp inserts the integers into the set in that order, he gets the string s. Since the answers might be large, print them modulo 998244353.
In the first example, there are three possible orderings before all queries: 
After the last query, there is only one possible ordering: " "2100  x3615"
1886C "Decreasing String" "implementation, strings" "Recall that string aa is lexicographically smaller than string b if a is a prefix of b (and a\xe2\x89\xa0b), or there exists an index i (1\xe2\x89\xa4i\xe2\x89\xa4min(|a|,|b|)) such that ai<bi, and for any index j (1\xe2\x89\xa4j<i) aj=bj.
Consider a sequence of strings s1,s2,\xe2\x80\xa6,sn, each consisting of lowercase Latin letters. String s1 is given explicitly, and all other strings are generated according to the following rule: to obtain the string si, a character is removed from string si\xe2\x88\x921 in such a way that string si is lexicographically minimal.
For example, if s1=dacb, then string s2=acb, string s3=ab, string s4=a.
After that, we obtain the string S=s1+s2+\xe2\x8b\xaf+sn (S is the concatenation of all strings s1,s2,\xe2\x80\xa6,sn).
You need to output the character in position pos of the string S (i.\xe2\x80\x89e. the character Spos).
The first line contains one integer t \xe2\x80\x94 the number of test cases (1\xe2\x89\xa4t\xe2\x89\xa4104).
Each test case consists of two lines. The first line contains the string s1 (1\xe2\x89\xa4|s1|\xe2\x89\xa4106), consisting of lowercase Latin letters. The second line contains the integer pos (1\xe2\x89\xa4pos\xe2\x89\xa4|s1|\xe2\x8b\x85(|s1|+1)2). You may assume that n is equal to the length of the given string (n=|s1|).
Additional constraint on the input: the sum of |s1| over all test cases does not exceed 106.
For each test case, print the answer \xe2\x80\x94 the character that is at position pos in string S. Note that the answers between different test cases are not separated by spaces or line breaks." "1600  x11702"
1886B "Fear of the Dark" "binary search, geometry, math" "Monocarp tries to get home from work. He is currently at the point O=(0,0) of a two-dimensional plane; his house is at the point P=(Px,Py).
Unfortunately, it is late in the evening, so it is very dark. Monocarp is afraid of the darkness. He would like to go home along a path illuminated by something.
Thankfully, there are two lanterns, located in the points A=(Ax,Ay) and B=(Bx,By). You can choose any non-negative number w and set the power of both lanterns to w. If a lantern\'s power is set to w, it illuminates a circle of radius w centered at the lantern location (including the borders of the circle).
You have to choose the minimum non-negative value w for the power of the lanterns in such a way that there is a path from the point O to the point P which is completely illuminated. You may assume that the lanterns don\'t interfere with Monocarp\'s movement.
The first line of the input contains one integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of test cases.
Each test case consists of three lines:
Additional constraint on the input:
For each test case, print the answer on a separate line \xe2\x80\x94 one real number equal to the minimum value of w such that there is a completely illuminated path from the point O to the point P.
Your answer will be considered correct if its absolute or relative error does not exceed 10\xe2\x88\x926 \xe2\x80\x94 formally, if your answer is a, and the jury\'s answer is b, your answer will be accepted if |a\xe2\x88\x92b|max(1,b)\xe2\x89\xa410\xe2\x88\x926." "1200  x16321"
1886A "Sum of Three" "brute force, constructive algorithms, math" "Monocarp has an integer n.
He wants to represent his number as a sum of three distinct positive integers x, y, and z. Additionally, Monocarp wants none of the numbers x, y, and z to be divisible by 3.
Your task is to help Monocarp to find any valid triplet of distinct positive integers x, y, and z, or report that such a triplet does not exist.
The first line contains a single integer t (1\xe2\x89\xa4t\xe2\x89\xa4104) \xe2\x80\x94 the number of testcases.
The only line of each testcase contains a single integer n (1\xe2\x89\xa4n\xe2\x89\xa4109).
For each testcase, if there is no valid triplet x, y, and z, print NO on the first line.
Otherwise, print YES on the first line. On the second line, print any valid triplet of distinct positive integers x, y, and z such that x+y+z=n, and none of the printed numbers are divisible by 3. If there are multiple valid triplets, you can print any of them.
In the first testcase, one of the valid triplets is x=4, y=5, z=1. None of these numbers are divisible by three, and 4+5+1=10.
In the second testcase, there is no valid triplet.
In the third testcase, one of the valid triplets is x=2, y=8, z=5. None of these numbers are divisible by three, and 2+8+5=15.
In the fourth testcase, there is no valid triplet." "800  x25983"
1885A "Deterministic Scheduling for Extended Reality over 5G and Beyond" "*special problem" "Background 
Extended reality (XR) service is a promising application for future communications. In wireless communications, XR data are transmitted over radio between base stations and mobile terminals. A region is usually divided into multiple cells, each of which is equipped with a base station to serve users. One base station usually serves multiple users, and multiple base stations may serve one user at the same time.
Task
The task of this competition is to design a scheduling algorithm for XR service. By properly allocating radio resources, we want to maximize the number of XR data frames that are successfully transmitted. A diagram is provided below for illustration: The transmission of a data frame is failed when it cannot be completely transmitted during the permitted transmission time window. 
Therefore, the objective of this task can be modeled as: P:max\xe2\x88\x91jfj fj={1,gj\xe2\x89\xa5TBSj0,gj<TBSj Here, fj represents the transmission result of the j-th frame: when the actual transmitted bits gj (computed via (5)) is not less than the size of the frame, i.e., TBSj (transport block size), the frame would be successfully transmitted so that fj=1. Otherwise, fj=0.
To achieve better user experience, scheduling algorithm should be proposed to efficiently assign the limited radio resources: 
Summarily, two optimization variables are introduced to represent the scheduling result: b(k)rnt\xe2\x88\x88{0,1} p(k)rnt\xe2\x89\xa50,\xe2\x88\x91r\xe2\x88\x91np(k)rnt\xe2\x89\xa4R,\xe2\x88\x91np(k)rnt\xe2\x89\xa44 Here, b(k)rnt is a Boolean variable denoting whether the r-th RBG of cell k is allocated to user n at TTI t, and p(k)rnt is a nonnegative continuous variable denoting the power allocated to user n in the r-th RBG of cell k at TTI t. For each TTI of each cell, the power range of each RBG is between 0 and 4, and the total power of all RBGs can not be larger than R.
When the radio resources are allocated to the users, the XR data transmission can be provided for them. Assume that the j-th frame belongs to the n-th user, the actual transmitted bits for the frame, i.e., gj can be given by:
gj=W\xc3\x97t1,j\xe2\x88\x91t=t0,j\xe2\x88\x91k\xe2\x88\x91rb(k)rnt\xc3\x97log2(1+s(k)nt). Note that W\xc3\x97log2(1+s(k)nt) is the well-known Shannon formula, which represents the transmitted data volume, where s(k)nt represents the transmission SINR (Signal-to-Interference-plus-Noise-Ratio) of user n in cell k at TTI t, and W=192 is the constant number of available frequency resounce elements of one RBG. t0,j and t1,j denote the start TTI and the end TTI of frame j, respectively. The physical meaning of Formula (5) is that the number of bits transmitted within the valid time period, t0,j\xe2\x88\xbct1,j, will be counted as valid transmission bits for the j-th frame. 
Finally, we give the expression of SINR, which may be complicated but corresponds to the actual physical transmission:
s(k)nt=(\xe2\x88\x8fr,b(k)rnt=1s(k)rnt)1\xe2\x88\x91rb(k)rnt s(k)rnt=s(k)0,rnt\xc3\x97p(k)rnt\xc3\x97\xe2\x88\x8fm\xe2\x89\xa0ned(k)mrn\xc3\x97b(k)rmt1+\xe2\x88\x91k\xe2\x80\xb2\xe2\x89\xa0k,n\xe2\x80\xb2\xe2\x89\xa0ns(k\xe2\x80\xb2)0,rnt\xc3\x97p(k\xe2\x80\xb2)rn\xe2\x80\xb2t\xc3\x97e\xe2\x88\x92d(k\xe2\x80\xb2)n\xe2\x80\xb2rn
Formula (6) shows the computation of user-level effective SINR: the transmission SINR of user n, i.e., s(k)nt, is the geometric mean of the SINRs of scheduled RBGs. Then, formula (7) shows the computation of RBG-level effective SINR. s(k)0,rnt is a given constant denoting the initial SINR on RBG r of cell k at TTI t, which indicates the quality of the channel. Another given constant value d(k)mrn represents the interference factor between user m and user n on RBG r, when user m is scheduled on cell k. Note that d(k)mrn=d(k)nrm\xe2\x89\xa40, which reveals that scheduling multiple users on the same RBG-TTI resource will cause a decrease in the SINR of each user.
To sum up, participants are required to find an efficient radio resource allocation, so that more XR data frames can be successfully transmitted.
 
The input of a single test has (4+R\xe2\x8b\x85K\xe2\x8b\x85T+N\xe2\x8b\x85R\xe2\x8b\x85K+1+J) lines, which contains user number N, cell number K, TTI number T, RBG number R, initial SINRs s(k)0,rnt, interference factors dmrn, frame number J and information about J frames. 
The details are as follows: 
Output for a certain input is the optimization result of p(k)rnt (float), which has R\xe2\x8b\x85K\xe2\x8b\x85T lines. Each line has N elements, corresponding to N users. p(k)rnt is the (n+1)-th element of line (1+r+k\xe2\x8b\x85R+t\xe2\x8b\x85K\xe2\x8b\x85R). 
Note that the optimization result of b(k)rnt does not need to be output, because p(k)rnt>0 and p(k)rnt=0 means b(k)rnt=1 and b(k)rnt=0, respectively.
Please note that if the outputs do not meet the constraint (4), it will be judged as an incorrect answer and get score 0. Besides, transmit on some TTIs out of time window is valid, but usually results in a lower score due to resources waste. 
The goal is to maximize the number of successfully scheduled frames. When these numbers are tied, we will compare who used less power. To achieve that, Score=X\xe2\x88\x9210\xe2\x88\x926\xc3\x97p, where X and p represent the number of successfully scheduled frames and the total power used for transmission, respectively.
The total score for a submission is the sum of scores on each test.
Two sets of tests are prepared in this problem. For the duration of the competition, each submission is tested on the preliminary set of tests. When the competition is finished, for each contestant:
The jury takes the latest submission with non-zero score on preliminary tests;
This submission is tested on the final set of tests for the final rank;
The two sets of tests are generated from the same pool of data, based on the real word data." "  1884E"
